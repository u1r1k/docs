import os
import logging
import signal
import sys
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters, CallbackQueryHandler
from audio_utils import AudioDownloader
from config import DEFAULT_SEARCH_RESULTS
from keep_alive import keep_alive

# ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹
ADMIN_ID = 1979411532
BOT_LINK = "https://t.me/music6383"

# Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

class SimpleTelegramMusicBot:
    def __init__(self, token: str):
        self.token = token
        self.downloader = AudioDownloader()
        self.user_search_results = {}
        self.subscribers = set()
        self.user_favorites = {}
        self.user_language = {}
        self.application = None

    def get_main_keyboard(self, is_admin=False, lang='ru'):
        if lang == 'en':
            keyboard = [
                ["ğŸµ Search Music", "ğŸ“‚ My Library"],
                ["â­ Top Charts", "â¤ï¸ Favorites"],
                ["ğŸ² Random Song", "ğŸ”§ Settings"],
                ["ğŸ“Š Statistics", "ğŸ†˜ Help"]
            ]
            if is_admin:
                keyboard.append(["âš™ï¸ Admin Panel"])
        else:
            keyboard = [
                ["ğŸµ ĞŸĞ¾Ğ¸ÑĞº Ğ¼ÑƒĞ·Ñ‹ĞºĞ¸", "ğŸ“‚ ĞœĞ¾Ñ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ°"],
                ["â­ Ğ¢Ğ¾Ğ¿ Ñ‡Ğ°Ñ€Ñ‚Ñ‹", "â¤ï¸ Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ"],
                ["ğŸ² Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ°Ñ Ğ¿ĞµÑĞ½Ñ", "ğŸ”§ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸"],
                ["ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", "ğŸ†˜ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ"]
            ]
            if is_admin:
                keyboard.append(["âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ"])
                
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    def get_search_inline_keyboard(self, tracks, lang='ru'):
        keyboard = []
        for i, track in enumerate(tracks):
            keyboard.append([InlineKeyboardButton(
                f"ğŸµ {track['title'][:30]}..." if len(track['title']) > 30 else f"ğŸµ {track['title']}", 
                callback_data=f"download_{i}"
            )])
        
        if lang == 'en':
            keyboard.append([InlineKeyboardButton("â¤ï¸ Add to Favorites", callback_data="add_favorite")])
            keyboard.append([InlineKeyboardButton("ğŸ”„ New Search", callback_data="new_search")])
        else:
            keyboard.append([InlineKeyboardButton("â¤ï¸ Ğ’ Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ", callback_data="add_favorite")])
            keyboard.append([InlineKeyboardButton("ğŸ”„ ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº", callback_data="new_search")])
            
        return InlineKeyboardMarkup(keyboard)

    def get_settings_keyboard(self, lang='ru'):
        if lang == 'en':
            keyboard = [
                [InlineKeyboardButton("ğŸŒ Language: English", callback_data="lang_ru")],
                [InlineKeyboardButton("ğŸ”Š Audio Quality: High", callback_data="quality_toggle")],
                [InlineKeyboardButton("ğŸ”” Notifications: ON", callback_data="notif_toggle")],
                [InlineKeyboardButton("ğŸ—‘ï¸ Clear History", callback_data="clear_history")],
                [InlineKeyboardButton("â¬…ï¸ Back to Menu", callback_data="back_menu")]
            ]
        else:
            keyboard = [
                [InlineKeyboardButton("ğŸŒ Ğ¯Ğ·Ñ‹Ğº: Ğ ÑƒÑÑĞºĞ¸Ğ¹", callback_data="lang_en")],
                [InlineKeyboardButton("ğŸ”Š ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾: Ğ’Ñ‹ÑĞ¾ĞºĞ¾Ğµ", callback_data="quality_toggle")],
                [InlineKeyboardButton("ğŸ”” Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ: Ğ’ĞšĞ›", callback_data="notif_toggle")],
                [InlineKeyboardButton("ğŸ—‘ï¸ ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ", callback_data="clear_history")],
                [InlineKeyboardButton("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ", callback_data="back_menu")]
            ]
        return InlineKeyboardMarkup(keyboard)

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        self.subscribers.add(user.id)
        lang = self.user_language.get(user.id, 'ru')
        
        welcome_text = {
            'ru': f"ğŸµ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, {user.first_name}!\n\nğŸ§ Ğ¯ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ñƒ Ñ‚ĞµĞ±Ğµ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¸ ÑĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ»ÑĞ±ÑƒÑ Ğ¼ÑƒĞ·Ñ‹ĞºÑƒ!\n\nğŸ’¡ ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ĞµÑĞ½Ğ¸ Ğ¸Ğ»Ğ¸ Ğ²Ğ¾ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ÑÑ ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸ Ğ½Ğ¸Ğ¶Ğµ:",
            'en': f"ğŸµ Hello, {user.first_name}!\n\nğŸ§ I'll help you find and download any music!\n\nğŸ’¡ Just send a song title or use the buttons below:"
        }
        
        await update.message.reply_text(
            welcome_text[lang],
            reply_markup=self.get_main_keyboard(is_admin=user.id == ADMIN_ID, lang=lang)
        )

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        help_text = {
            'ru': """ğŸ†˜ **ĞŸĞĞœĞĞ©Ğ¬**

ğŸµ **ĞŸĞ¾Ğ¸ÑĞº Ğ¼ÑƒĞ·Ñ‹ĞºĞ¸:**
â€¢ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ĞµÑĞ½Ğ¸
â€¢ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: "Believer Imagine Dragons"

ğŸ¯ **ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:**
â€¢ /start - Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ
â€¢ /help - Ğ­Ñ‚Ğ° ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ°
â€¢ /stats - Ğ¢Ğ²Ğ¾Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°

ğŸ’¡ **Ğ¡Ğ¾Ğ²ĞµÑ‚Ñ‹:**
â€¢ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ
â€¢ Ğ£ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞ¸Ñ… Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ²
â€¢ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞ¹ Ğ¿ĞµÑĞ½Ğ¸ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ â¤ï¸

ğŸ¤– **Ğ¤Ğ¸ÑˆĞºĞ¸:**
â€¢ Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ°Ñ Ğ¼ÑƒĞ·Ñ‹ĞºĞ° ğŸ²
â€¢ Ğ¢Ğ¾Ğ¿ Ñ‡Ğ°Ñ€Ñ‚Ñ‹ â­
â€¢ ĞŸĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ° ğŸ“‚""",
            'en': """ğŸ†˜ **HELP**

ğŸµ **Music Search:**
â€¢ Send song title
â€¢ Example: "Believer Imagine Dragons"

ğŸ¯ **Commands:**
â€¢ /start - Main menu
â€¢ /help - This help
â€¢ /stats - Your statistics

ğŸ’¡ **Tips:**
â€¢ Use exact titles
â€¢ Specify artist for better results
â€¢ Add songs to favorites â¤ï¸

ğŸ¤– **Features:**
â€¢ Random music ğŸ²
â€¢ Top charts â­
â€¢ Personal library ğŸ“‚"""
        }
        
        await update.message.reply_text(help_text[lang], parse_mode='Markdown')

    async def handle_button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        user_id = query.from_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        await query.answer()
        
        if query.data.startswith("download_"):
            await self.download_by_callback(update, context)
        elif query.data == "add_favorite":
            await self.add_to_favorites(update, context)
        elif query.data == "new_search":
            text = "ğŸ” ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿ĞµÑĞ½Ğ¸:" if lang == 'ru' else "ğŸ” Send new song title:"
            await query.edit_message_text(text)
        elif query.data.startswith("lang_"):
            await self.change_language(update, context)
        elif query.data == "quality_toggle":
            text = "ğŸ”Š ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾!" if lang == 'ru' else "ğŸ”Š Quality changed!"
            await query.edit_message_text(text)
        elif query.data == "notif_toggle":
            text = "ğŸ”” ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ñ‹!" if lang == 'ru' else "ğŸ”” Notification settings changed!"
            await query.edit_message_text(text)
        elif query.data == "clear_history":
            if user_id in self.user_search_results:
                del self.user_search_results[user_id]
            text = "ğŸ—‘ï¸ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ°!" if lang == 'ru' else "ğŸ—‘ï¸ History cleared!"
            await query.edit_message_text(text)
        elif query.data == "back_menu":
            text = "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ:" if lang == 'ru' else "ğŸ  Main menu:"
            await query.edit_message_text(text, reply_markup=None)
        elif query.data == "admin_broadcast":
            if user_id == ADMIN_ID:
                text = "ğŸ“¢ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸:\n\n/broadcast [Ñ‚Ğ²Ğ¾Ñ‘ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ]" if lang == 'ru' else "ğŸ“¢ Send message for broadcast:\n\n/broadcast [your message]"
                await query.edit_message_text(text)
        elif query.data == "admin_stats":
            if user_id == ADMIN_ID:
                await self.detailed_admin_stats(update, context)
        elif query.data == "admin_restart":
            if user_id == ADMIN_ID:
                text = "ğŸ”„ Ğ‘Ğ¾Ñ‚ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½ Ñ‡ĞµÑ€ĞµĞ· 3 ÑĞµĞºÑƒĞ½Ğ´Ñ‹..." if lang == 'ru' else "ğŸ”„ Bot will restart in 3 seconds..."
                await query.edit_message_text(text)

    async def download_by_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        user_id = query.from_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        if user_id not in self.user_search_results:
            text = "â— Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ½Ğ°Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿ĞµÑĞ½Ñ!" if lang == 'ru' else "â— Search for a song first!"
            await query.edit_message_text(text)
            return

        try:
            idx = int(query.data.split("_")[1])
            tracks = self.user_search_results[user_id]
            
            if not 0 <= idx < len(tracks):
                text = "âš ï¸ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€!" if lang == 'ru' else "âš ï¸ Invalid selection!"
                await query.edit_message_text(text)
                return

            track = tracks[idx]
            loading_text = f"â¬‡ï¸ Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ñ: {track['title']}" if lang == 'ru' else f"â¬‡ï¸ Downloading: {track['title']}"
            await query.edit_message_text(loading_text)

            filepath = self.downloader.download_track(track['id'], track['title'])
            if filepath:
                with open(filepath, "rb") as audio:
                    caption = f"ğŸµ {track['title']}\nğŸ‘¤ {track['uploader']}\n\nğŸ¤– ĞœÑƒĞ·Ñ‹ĞºĞ° Ğ¾Ñ‚ Ğ±Ğ¾Ñ‚Ğ° {BOT_LINK}"
                    await context.bot.send_audio(
                        chat_id=query.message.chat_id,
                        audio=audio,
                        title=track['title'],
                        performer=track['uploader'],
                        caption=caption
                    )
                
                success_text = "âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! ĞĞ°ÑĞ»Ğ°Ğ¶Ğ´Ğ°Ğ¹ÑÑ Ğ¼ÑƒĞ·Ñ‹ĞºĞ¾Ğ¹! ğŸ§" if lang == 'ru' else "âœ… Done! Enjoy the music! ğŸ§"
                await query.edit_message_text(success_text)
                
                try:
                    os.remove(filepath)
                except:
                    pass
            else:
                error_text = "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»." if lang == 'ru' else "âŒ Failed to download file."
                await query.edit_message_text(error_text)
        except Exception as e:
            logger.error(f"Callback download error: {e}")
            error_text = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ." if lang == 'ru' else "âŒ Download error."
            await query.edit_message_text(error_text)

    async def add_to_favorites(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        user_id = query.from_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        if user_id not in self.user_favorites:
            self.user_favorites[user_id] = []
        
        if user_id in self.user_search_results and self.user_search_results[user_id]:
            track = self.user_search_results[user_id][0]
            if track not in self.user_favorites[user_id]:
                self.user_favorites[user_id].append(track)
                text = f"â¤ï¸ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ!" if lang == 'ru' else f"â¤ï¸ Added to favorites!"
            else:
                text = "âš ï¸ Ğ£Ğ¶Ğµ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¼!" if lang == 'ru' else "âš ï¸ Already in favorites!"
        else:
            text = "â— ĞĞµÑ‚ Ñ‚Ñ€ĞµĞºĞ¾Ğ² Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ!" if lang == 'ru' else "â— No tracks to add!"
            
        await query.edit_message_text(text)

    async def change_language(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        user_id = query.from_user.id
        
        new_lang = query.data.split("_")[1]
        self.user_language[user_id] = new_lang
        
        if new_lang == 'en':
            text = "ğŸ‡ºğŸ‡¸ Language changed to English!"
        else:
            text = "ğŸ‡·ğŸ‡º Ğ¯Ğ·Ñ‹Ğº Ğ¸Ğ·Ğ¼ĞµĞ½Ñ‘Ğ½ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¸Ğ¹!"
            
        await query.edit_message_text(text, reply_markup=self.get_settings_keyboard(new_lang))

    async def search_music(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        query = update.message.text.strip()
        lang = self.user_language.get(user_id, 'ru')

        if not query or query.startswith("/"):
            return

        search_text = f"ğŸ” Ğ˜Ñ‰Ñƒ: {query}" if lang == 'ru' else f"ğŸ” Searching: {query}"
        msg = await update.message.reply_text(search_text)
        
        try:
            tracks = self.downloader.search_tracks(query, DEFAULT_SEARCH_RESULTS)
            if not tracks:
                no_results = "âŒ ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ." if lang == 'ru' else "âŒ Nothing found. Try another search."
                await msg.edit_text(no_results)
                return

            self.user_search_results[user_id] = tracks
            
            result_text = "ğŸ¶ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾:\n\n" if lang == 'ru' else "ğŸ¶ Found:\n\n"
            for i, track in enumerate(tracks):
                result_text += f"{i+1}. ğŸµ {track['title']}\n"
                result_text += f"   ğŸ‘¤ {track['uploader']} | â° {track['duration']}\n\n"

            instruction = "ğŸ‘‡ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ Ñ‚Ñ€ĞµĞº ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ Ğ½Ğ¸Ğ¶Ğµ:" if lang == 'ru' else "ğŸ‘‡ Select track with button below:"
            result_text += instruction

            await msg.edit_text(
                result_text,
                reply_markup=self.get_search_inline_keyboard(tracks, lang)
            )
        except Exception as e:
            logger.error(f"Search error: {e}")
            error_text = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ Ğ¿Ğ¾Ğ·Ğ¶Ğµ." if lang == 'ru' else "âŒ Search error. Try later."
            await msg.edit_text(error_text)

    async def handle_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        text = update.message.text.strip()
        lang = self.user_language.get(user_id, 'ru')

        button_handlers = {
            "ğŸµ ĞŸĞ¾Ğ¸ÑĞº Ğ¼ÑƒĞ·Ñ‹ĞºĞ¸": lambda: update.message.reply_text("ğŸ” ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ĞµÑĞ½Ğ¸:"),
            "ğŸ“‚ ĞœĞ¾Ñ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ°": self.show_library,
            "â­ Ğ¢Ğ¾Ğ¿ Ñ‡Ğ°Ñ€Ñ‚Ñ‹": self.show_top_charts,
            "â¤ï¸ Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ": self.show_favorites,
            "ğŸ² Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ°Ñ Ğ¿ĞµÑĞ½Ñ": self.random_song,
            "ğŸ”§ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸": self.show_settings,
            "ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°": self.show_stats,
            "ğŸ†˜ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ": self.help_command,
            "âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ": self.admin_panel,
            
            "ğŸµ Search Music": lambda: update.message.reply_text("ğŸ” Send song title:"),
            "ğŸ“‚ My Library": self.show_library,
            "â­ Top Charts": self.show_top_charts,
            "â¤ï¸ Favorites": self.show_favorites,
            "ğŸ² Random Song": self.random_song,
            "ğŸ”§ Settings": self.show_settings,
            "ğŸ“Š Statistics": self.show_stats,
            "ğŸ†˜ Help": self.help_command,
            "âš™ï¸ Admin Panel": self.admin_panel,
        }

        if text in button_handlers:
            return await button_handlers[text](update, context)
        elif text.isdigit():
            return await self.download_by_number(update, context)
        else:
            return await self.search_music(update, context)

    async def show_library(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        text = "ğŸ“‚ Ğ¢Ğ²Ğ¾Ñ Ğ¼ÑƒĞ·Ñ‹ĞºĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ°:\n\nğŸµ ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¸ÑĞºĞ¸\nâ¤ï¸ Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞºĞ¸\nğŸ“ˆ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¾Ğº" if lang == 'ru' else "ğŸ“‚ Your music library:\n\nğŸµ Recent searches\nâ¤ï¸ Favorite tracks\nğŸ“ˆ Download history"
        await update.message.reply_text(text)

    async def show_top_charts(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        lang = self.user_language.get(update.effective_user.id, 'ru')
        
        top_songs = [
            "ğŸ† Imagine Dragons - Believer",
            "ğŸ¥ˆ Ed Sheeran - Shape of You", 
            "ğŸ¥‰ The Weeknd - Blinding Lights",
            "4ï¸âƒ£ Dua Lipa - Levitating",
            "5ï¸âƒ£ Post Malone - Circles"
        ]
        
        text = "â­ **Ğ¢ĞĞŸ Ğ§ĞĞ Ğ¢Ğ«:**\n\n" + "\n".join(top_songs) if lang == 'ru' else "â­ **TOP CHARTS:**\n\n" + "\n".join(top_songs)
        await update.message.reply_text(text, parse_mode='Markdown')

    async def show_favorites(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        if user_id not in self.user_favorites or not self.user_favorites[user_id]:
            text = "â¤ï¸ Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ¿ÑƒÑÑ‚Ğ¾.\nĞ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ¿ĞµÑĞ½Ğ¸ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ!" if lang == 'ru' else "â¤ï¸ Favorites empty.\nAdd songs to favorites when searching!"
        else:
            text = "â¤ï¸ **Ğ˜Ğ—Ğ‘Ğ ĞĞĞĞĞ•:**\n\n" if lang == 'ru' else "â¤ï¸ **FAVORITES:**\n\n"
            for i, track in enumerate(self.user_favorites[user_id][:10]):
                text += f"{i+1}. ğŸµ {track['title']}\n"
        
        await update.message.reply_text(text, parse_mode='Markdown')

    async def random_song(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        lang = self.user_language.get(update.effective_user.id, 'ru')
        
        random_queries = ["popular music", "top hits 2024", "best songs", "trending music", "viral songs"]
        import random
        query = random.choice(random_queries)
        
        msg_text = "ğŸ² Ğ˜Ñ‰Ñƒ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½ÑƒÑ Ğ¿ĞµÑĞ½Ñ..." if lang == 'ru' else "ğŸ² Finding random song..."
        msg = await update.message.reply_text(msg_text)
        
        try:
            tracks = self.downloader.search_tracks(query, 1)
            if tracks:
                track = tracks[0]
                self.user_search_results[update.effective_user.id] = tracks
                
                text = f"ğŸ² **Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ°Ñ Ğ¿ĞµÑĞ½Ñ:**\n\nğŸµ {track['title']}\nğŸ‘¤ {track['uploader']}\nâ° {track['duration']}" if lang == 'ru' else f"ğŸ² **Random song:**\n\nğŸµ {track['title']}\nğŸ‘¤ {track['uploader']}\nâ° {track['duration']}"
                
                keyboard = [[InlineKeyboardButton("â¬‡ï¸ Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ" if lang == 'ru' else "â¬‡ï¸ Download", callback_data="download_0")]]
                await msg.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
            else:
                error_text = "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½ÑƒÑ Ğ¿ĞµÑĞ½Ñ." if lang == 'ru' else "âŒ Failed to find random song."
                await msg.edit_text(error_text)
        except Exception as e:
            logger.error(f"Random song error: {e}")
            error_text = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ." if lang == 'ru' else "âŒ Search error."
            await msg.edit_text(error_text)

    async def show_settings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        text = "ğŸ”§ **ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜:**" if lang == 'ru' else "ğŸ”§ **SETTINGS:**"
        await update.message.reply_text(
            text, 
            reply_markup=self.get_settings_keyboard(lang),
            parse_mode='Markdown'
        )

    async def show_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        searches = len(self.user_search_results.get(user_id, []))
        favorites = len(self.user_favorites.get(user_id, []))
        
        if lang == 'ru':
            text = f"""ğŸ“Š **Ğ¢Ğ’ĞĞ¯ Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:**

ğŸ” ĞŸĞ¾Ğ¸ÑĞºĞ¾Ğ²: {searches}
â¤ï¸ Ğ’ Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¼: {favorites}
ğŸµ Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾: {searches * 2}
â­ Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³: ĞœĞµĞ»Ğ¾Ğ¼Ğ°Ğ½
ğŸ¯ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ: Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ"""
        else:
            text = f"""ğŸ“Š **YOUR STATISTICS:**

ğŸ” Searches: {searches}
â¤ï¸ Favorites: {favorites}
ğŸµ Downloaded: {searches * 2}
â­ Rating: Music Lover
ğŸ¯ Activity: High"""
        
        await update.message.reply_text(text, parse_mode='Markdown')

    async def admin_panel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != ADMIN_ID:
            return
            
        lang = self.user_language.get(update.effective_user.id, 'ru')
        
        if lang == 'ru':
            text = f"""âš™ï¸ **ĞĞ”ĞœĞ˜Ğ ĞŸĞĞĞ•Ğ›Ğ¬:**

ğŸ‘¥ ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ¾Ğ²: {len(self.subscribers)}
ğŸ” ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²: {len(self.user_search_results)}
â¤ï¸ ĞĞ±Ñ‰ĞµĞµ Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ: {sum(len(favs) for favs in self.user_favorites.values())}
ğŸ“Š Ğ¯Ğ·Ñ‹ĞºĞ¸: RU={sum(1 for l in self.user_language.values() if l=='ru')}, EN={sum(1 for l in self.user_language.values() if l=='en')}

ğŸ¤– Ğ‘Ğ¾Ñ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾!

ğŸ’¬ Ğ”Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ: /broadcast [ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ]"""
        else:
            text = f"""âš™ï¸ **ADMIN PANEL:**

ğŸ‘¥ Subscribers: {len(self.subscribers)}
ğŸ” Active searches: {len(self.user_search_results)}
â¤ï¸ Total favorites: {sum(len(favs) for favs in self.user_favorites.values())}
ğŸ“Š Languages: RU={sum(1 for l in self.user_language.values() if l=='ru')}, EN={sum(1 for l in self.user_language.values() if l=='en')}

ğŸ¤– Bot working stable!

ğŸ’¬ For broadcast send: /broadcast [message]"""
        
        keyboard = [
            [InlineKeyboardButton("ğŸ“¢ Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ°" if lang == 'ru' else "ğŸ“¢ Broadcast", callback_data="admin_broadcast")],
            [InlineKeyboardButton("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°" if lang == 'ru' else "ğŸ“Š Statistics", callback_data="admin_stats")],
            [InlineKeyboardButton("ğŸ”„ ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°" if lang == 'ru' else "ğŸ”„ Restart", callback_data="admin_restart")]
        ]
        
        await update.message.reply_text(
            text, 
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def broadcast_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != ADMIN_ID:
            return
            
        lang = self.user_language.get(update.effective_user.id, 'ru')
        
        if not context.args:
            text = "âŒ Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚: /broadcast [ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ]" if lang == 'ru' else "âŒ Format: /broadcast [message]"
            await update.message.reply_text(text)
            return
            
        broadcast_text = " ".join(context.args)
        
        if len(broadcast_text) > 4000:
            text = "âŒ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ! ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 4000 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²." if lang == 'ru' else "âŒ Message too long! Max 4000 characters."
            await update.message.reply_text(text)
            return
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğº Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞµ
        header = "ğŸ“¢ **Ğ ĞĞ¡Ğ¡Ğ«Ğ›ĞšĞ ĞĞ¢ ĞĞ”ĞœĞ˜ĞĞ˜Ğ¡Ğ¢Ğ ĞĞ¢ĞĞ Ğ:**\n\n" if lang == 'ru' else "ğŸ“¢ **BROADCAST FROM ADMIN:**\n\n"
        final_message = header + broadcast_text + f"\n\nğŸ¤– {BOT_LINK}"
        
        sent_count = 0
        failed_count = 0
        
        status_msg = await update.message.reply_text(
            f"ğŸ“¤ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ Ğ´Ğ»Ñ {len(self.subscribers)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹..." if lang == 'ru' 
            else f"ğŸ“¤ Starting broadcast for {len(self.subscribers)} users..."
        )
        
        for user_id in list(self.subscribers):
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=final_message,
                    parse_mode='Markdown'
                )
                sent_count += 1
                
                # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10 Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğº
                if sent_count % 10 == 0:
                    await status_msg.edit_text(
                        f"ğŸ“¤ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {sent_count}/{len(self.subscribers)}" if lang == 'ru'
                        else f"ğŸ“¤ Sent: {sent_count}/{len(self.subscribers)}"
                    )
                    
            except Exception as e:
                failed_count += 1
                # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
                if "blocked" in str(e).lower() or "not found" in str(e).lower():
                    self.subscribers.discard(user_id)
                logger.error(f"Broadcast error for user {user_id}: {e}")
        
        # Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ñ‡ĞµÑ‚
        if lang == 'ru':
            final_text = f"""âœ… **Ğ ĞĞ¡Ğ¡Ğ«Ğ›ĞšĞ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ!**

ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:
â€¢ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {sent_count}
â€¢ ĞÑˆĞ¸Ğ±Ğ¾Ğº: {failed_count}
â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {len(self.subscribers)}

ğŸ“ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: {broadcast_text[:100]}{'...' if len(broadcast_text) > 100 else ''}"""
        else:
            final_text = f"""âœ… **BROADCAST COMPLETED!**

ğŸ“Š Statistics:
â€¢ Sent: {sent_count}
â€¢ Failed: {failed_count}
â€¢ Active users: {len(self.subscribers)}

ğŸ“ Message: {broadcast_text[:100]}{'...' if len(broadcast_text) > 100 else ''}"""
        
        await status_msg.edit_text(final_text, parse_mode='Markdown')

    async def detailed_admin_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        lang = self.user_language.get(query.from_user.id, 'ru')
        
        total_searches = sum(len(searches) for searches in self.user_search_results.values())
        total_favorites = sum(len(favs) for favs in self.user_favorites.values())
        ru_users = sum(1 for l in self.user_language.values() if l == 'ru')
        en_users = sum(1 for l in self.user_language.values() if l == 'en')
        
        if lang == 'ru':
            text = f"""ğŸ“Š **Ğ”Ğ•Ğ¢ĞĞ›Ğ¬ĞĞĞ¯ Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ:**

ğŸ‘¥ **ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸:**
â€¢ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ¾Ğ²: {len(self.subscribers)}
â€¢ Ğ ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº: {ru_users}
â€¢ ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº: {en_users}
â€¢ ĞĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‘Ğ½Ğ½Ñ‹Ğ¹: {len(self.subscribers) - ru_users - en_users}

ğŸµ **ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ:**
â€¢ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²: {total_searches}
â€¢ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞµÑÑĞ¸Ğ¹: {len(self.user_search_results)}
â€¢ Ğ¢Ñ€ĞµĞºĞ¾Ğ² Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¼: {total_favorites}
â€¢ Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ: {total_searches / max(len(self.subscribers), 1):.1f}

ğŸ’¾ **ĞŸĞ°Ğ¼ÑÑ‚ÑŒ:**
â€¢ ĞšÑÑˆ Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²: {len(self.user_search_results)} ÑĞµÑÑĞ¸Ğ¹
â€¢ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾: {len(self.user_favorites)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
â€¢ Ğ¯Ğ·Ñ‹ĞºĞ¾Ğ²Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸: {len(self.user_language)} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹"""
        else:
            text = f"""ğŸ“Š **DETAILED STATISTICS:**

ğŸ‘¥ **Users:**
â€¢ Total subscribers: {len(self.subscribers)}
â€¢ Russian language: {ru_users}
â€¢ English language: {en_users}
â€¢ Undefined: {len(self.subscribers) - ru_users - en_users}

ğŸµ **Activity:**
â€¢ Total searches: {total_searches}
â€¢ Active sessions: {len(self.user_search_results)}
â€¢ Favorite tracks: {total_favorites}
â€¢ Average activity: {total_searches / max(len(self.subscribers), 1):.1f}

ğŸ’¾ **Memory:**
â€¢ Search cache: {len(self.user_search_results)} sessions
â€¢ Favorites data: {len(self.user_favorites)} users
â€¢ Language settings: {len(self.user_language)} records"""
        
        await query.edit_message_text(text, parse_mode='Markdown')

    async def download_by_number(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        lang = self.user_language.get(user_id, 'ru')
        
        if user_id not in self.user_search_results:
            text = "â— Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ĞµÑĞ½Ğ¸ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°." if lang == 'ru' else "â— Search for a song first."
            return await update.message.reply_text(text)

        try:
            idx = int(update.message.text) - 1
            tracks = self.user_search_results[user_id]
            if not 0 <= idx < len(tracks):
                text = "âš ï¸ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚Ñ€ĞµĞºĞ°." if lang == 'ru' else "âš ï¸ Invalid track number."
                return await update.message.reply_text(text)

            track = tracks[idx]
            loading_text = f"â¬‡ï¸ Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ñ: {track['title']}" if lang == 'ru' else f"â¬‡ï¸ Downloading: {track['title']}"
            msg = await update.message.reply_text(loading_text)

            filepath = self.downloader.download_track(track['id'], track['title'])
            if filepath:
                with open(filepath, "rb") as audio:
                    caption = f"ğŸµ {track['title']}\nğŸ‘¤ {track['uploader']}\n\nğŸ¤– ĞœÑƒĞ·Ñ‹ĞºĞ° Ğ¾Ñ‚ Ğ±Ğ¾Ñ‚Ğ° {BOT_LINK}"
                    await context.bot.send_audio(
                        chat_id=update.effective_chat.id,
                        audio=audio,
                        title=track['title'],
                        performer=track['uploader'],
                        caption=caption
                    )
                await msg.delete()
                
                try:
                    os.remove(filepath)
                except:
                    pass
            else:
                error_text = "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»." if lang == 'ru' else "âŒ Failed to download file."
                await msg.edit_text(error_text)
        except Exception as e:
            logger.error(f"Download error: {e}")
            error_text = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ Ñ‚Ñ€ĞµĞºĞ°." if lang == 'ru' else "âŒ Track download error."
            await update.message.reply_text(error_text)

    def signal_handler(self, signum, frame):
        print("ğŸ›‘ ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ, Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°Ñ Ğ±Ğ¾Ñ‚Ğ°...")
        if self.application:
            self.application.stop_running()
        sys.exit(0)

    def run(self):
        # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ keep-alive Ñ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ñ‹Ğ¼ Ğ¿Ğ¸Ğ½Ğ³Ğ¾Ğ¼
        keep_alive()
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½ Ğ±Ğ¾Ñ‚Ğ°
        print("ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑÑ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Telegram...")
        
        self.application = Application.builder().token(self.token).build()

        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("stats", self.show_stats))
        self.application.add_handler(CommandHandler("broadcast", self.broadcast_message))
        self.application.add_handler(CallbackQueryHandler(self.handle_button_callback))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_text))

        print("ğŸš€ ĞœÑƒĞ·Ñ‹ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ±Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½!")
        print("âœ¨ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸:")
        print("   ğŸµ ĞŸĞ¾Ğ¸ÑĞº Ğ¸ ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¼ÑƒĞ·Ñ‹ĞºĞ¸")
        print("   ğŸ² Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ°Ñ Ğ¼ÑƒĞ·Ñ‹ĞºĞ°")
        print("   â¤ï¸ Ğ˜Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ")
        print("   ğŸŒ Ğ ÑƒÑÑĞºĞ¸Ğ¹/ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹")
        print("   âš™ï¸ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°")
        print("   ğŸ“Š ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ")
        
        try:
            self.application.run_polling(drop_pending_updates=True)
        except Exception as e:
            logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°: {e}")
            print("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ Ğ±Ğ¾Ñ‚Ğ°")

def main():
    token = "6409245799:AAECfJLSS5-eeI-SOga9l7k4lmMn84RdG2g"
    bot = SimpleTelegramMusicBot(token)
    bot.run()

if __name__ == "__main__":
    main()
